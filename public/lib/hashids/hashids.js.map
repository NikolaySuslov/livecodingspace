{"version":3,"sources":["../lib/hashids.ts"],"names":[],"mappings":"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","file":"hashids.js","sourcesContent":["type NumberLike = number | bigint\n\nexport default class Hashids {\n  private alphabet: string[]\n  private seps: string[]\n  private guards: string[]\n  private salt: string[]\n  private guardsRegExp: RegExp\n  private sepsRegExp: RegExp\n  private allowedCharsRegExp: RegExp\n\n  public constructor(\n    salt = '',\n    private minLength = 0,\n    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890',\n    seps = 'cfhistuCFHISTU',\n  ) {\n    if (typeof minLength !== 'number') {\n      throw new TypeError(\n        `Hashids: Provided 'minLength' has to be a number (is ${typeof minLength})`,\n      )\n    }\n    if (typeof salt !== 'string') {\n      throw new TypeError(\n        `Hashids: Provided 'salt' has to be a string (is ${typeof salt})`,\n      )\n    }\n    if (typeof alphabet !== 'string') {\n      throw new TypeError(\n        `Hashids: Provided alphabet has to be a string (is ${typeof alphabet})`,\n      )\n    }\n\n    const saltChars = Array.from(salt)\n    const alphabetChars = Array.from(alphabet)\n    const sepsChars = Array.from(seps)\n\n    this.salt = saltChars\n\n    const uniqueAlphabet = keepUnique(alphabetChars)\n\n    if (uniqueAlphabet.length < minAlphabetLength) {\n      throw new Error(\n        `Hashids: alphabet must contain at least ${minAlphabetLength} unique characters, provided: ${uniqueAlphabet}`,\n      )\n    }\n\n    /** `alphabet` should not contains `seps` */\n    this.alphabet = withoutChars(uniqueAlphabet, sepsChars)\n    /** `seps` should contain only characters present in `alphabet` */\n    const filteredSeps = onlyChars(sepsChars, uniqueAlphabet)\n    this.seps = shuffle(filteredSeps, saltChars)\n\n    let sepsLength\n    let diff\n\n    if (\n      this.seps.length === 0 ||\n      this.alphabet.length / this.seps.length > sepDiv\n    ) {\n      sepsLength = Math.ceil(this.alphabet.length / sepDiv)\n\n      if (sepsLength > this.seps.length) {\n        diff = sepsLength - this.seps.length\n        this.seps.push(...this.alphabet.slice(0, diff))\n        this.alphabet = this.alphabet.slice(diff)\n      }\n    }\n\n    this.alphabet = shuffle(this.alphabet, saltChars)\n    const guardCount = Math.ceil(this.alphabet.length / guardDiv)\n\n    if (this.alphabet.length < 3) {\n      this.guards = this.seps.slice(0, guardCount)\n      this.seps = this.seps.slice(guardCount)\n    } else {\n      this.guards = this.alphabet.slice(0, guardCount)\n      this.alphabet = this.alphabet.slice(guardCount)\n    }\n\n    this.guardsRegExp = makeAnyOfCharsRegExp(this.guards)\n    this.sepsRegExp = makeAnyOfCharsRegExp(this.seps)\n    this.allowedCharsRegExp = makeAtLeastSomeCharRegExp([\n      ...this.alphabet,\n      ...this.guards,\n      ...this.seps,\n    ])\n  }\n\n  public encode(numbers: string): string\n  public encode(numbers: NumberLike[]): string\n  public encode(...numbers: NumberLike[]): string\n  public encode(numbers: string[]): string\n  public encode(...numbers: string[]): string\n  public encode<T extends string | NumberLike>(\n    first: T[] | T,\n    ...numbers: T[]\n  ): string {\n    const ret = ''\n\n    if (Array.isArray(first)) {\n      numbers = first\n    } else {\n      // eslint-disable-next-line eqeqeq\n      numbers = [...(first != null ? [first] : []), ...numbers]\n    }\n\n    if (!numbers.length) {\n      return ret\n    }\n\n    if (!numbers.every(isIntegerNumber)) {\n      numbers = numbers.map((n) =>\n        typeof n === 'bigint' || typeof n === 'number'\n          ? n\n          : safeParseInt10(String(n)),\n      ) as T[]\n    }\n\n    if (!(numbers as NumberLike[]).every(isPositiveAndFinite)) {\n      return ret\n    }\n\n    return this._encode(numbers as number[]).join('')\n  }\n\n  public decode(id: string): NumberLike[] {\n    if (!id || typeof id !== 'string' || id.length === 0) return []\n    return this._decode(id)\n  }\n\n  /**\n   * @description Splits a hex string into groups of 12-digit hexadecimal numbers,\n   * then prefixes each with '1' and encodes the resulting array of numbers\n   *\n   * Encoding '00000000000f00000000000f000f' would be the equivalent of:\n   * Hashids.encode([0x100000000000f, 0x100000000000f, 0x1000f])\n   *\n   * This means that if your environment supports BigInts,\n   * you will get different (shorter) results if you provide\n   * a BigInt representation of your hex and use `encode` directly, e.g.:\n   * Hashids.encode(BigInt(`0x${hex}`))\n   *\n   * To decode such a representation back to a hex string, use the following snippet:\n   * Hashids.decode(id)[0].toString(16)\n   */\n  public encodeHex(hex: string | bigint): string {\n    switch (typeof hex) {\n      case 'bigint':\n        hex = hex.toString(16)\n        break\n      case 'string':\n        if (!/^[0-9a-fA-F]+$/.test(hex)) return ''\n        break\n      default:\n        throw new Error(\n          `Hashids: The provided value is neither a string, nor a BigInt (got: ${typeof hex})`,\n        )\n    }\n\n    const numbers = splitAtIntervalAndMap(hex, 12, (part) =>\n      parseInt(`1${part}`, 16),\n    )\n    return this.encode(numbers)\n  }\n\n  public decodeHex(id: string) {\n    return this.decode(id)\n      .map((number) => number.toString(16).slice(1))\n      .join('')\n  }\n\n  private _encode(numbers: NumberLike[]): string[] {\n    let alphabet = this.alphabet\n\n    const numbersIdInt = numbers.reduce<number>(\n      (last, number, i) =>\n        last +\n        (typeof number === 'bigint'\n          ? Number(number % BigInt(i + 100))\n          : number % (i + 100)),\n      0,\n    )\n\n    let ret: string[] = [alphabet[numbersIdInt % alphabet.length]]\n    const lottery = ret.slice()\n\n    const seps = this.seps\n    const guards = this.guards\n\n    numbers.forEach((number, i) => {\n      const buffer = lottery.concat(this.salt, alphabet)\n\n      alphabet = shuffle(alphabet, buffer)\n      const last = toAlphabet(number, alphabet)\n\n      ret.push(...last)\n\n      if (i + 1 < numbers.length) {\n        const charCode = last[0].codePointAt(0)! + i\n        const extraNumber =\n          typeof number === 'bigint'\n            ? Number(number % BigInt(charCode))\n            : number % charCode\n        ret.push(seps[extraNumber % seps.length])\n      }\n    })\n\n    if (ret.length < this.minLength) {\n      const prefixGuardIndex =\n        (numbersIdInt + ret[0].codePointAt(0)!) % guards.length\n      ret.unshift(guards[prefixGuardIndex])\n\n      if (ret.length < this.minLength) {\n        const suffixGuardIndex =\n          (numbersIdInt + ret[2].codePointAt(0)!) % guards.length\n        ret.push(guards[suffixGuardIndex])\n      }\n    }\n\n    const halfLength = Math.floor(alphabet.length / 2)\n    while (ret.length < this.minLength) {\n      alphabet = shuffle(alphabet, alphabet)\n      ret.unshift(...alphabet.slice(halfLength))\n      ret.push(...alphabet.slice(0, halfLength))\n\n      const excess = ret.length - this.minLength\n      if (excess > 0) {\n        const halfOfExcess = excess / 2\n        ret = ret.slice(halfOfExcess, halfOfExcess + this.minLength)\n      }\n    }\n\n    return ret\n  }\n\n  public isValidId(id: string): boolean {\n    return this.allowedCharsRegExp.test(id)\n  }\n\n  private _decode(id: string): NumberLike[] {\n    if (!this.isValidId(id)) {\n      throw new Error(\n        `The provided ID (${id}) is invalid, as it contains characters that do not exist in the alphabet (${this.guards.join(\n          '',\n        )}${this.seps.join('')}${this.alphabet.join('')})`,\n      )\n    }\n    const idGuardsArray = id.split(this.guardsRegExp)\n    const splitIndex =\n      idGuardsArray.length === 3 || idGuardsArray.length === 2 ? 1 : 0\n\n    const idBreakdown = idGuardsArray[splitIndex]\n    if (idBreakdown.length === 0) return []\n\n    const lotteryChar = idBreakdown[Symbol.iterator]().next().value as string\n    const idArray = idBreakdown.slice(lotteryChar.length).split(this.sepsRegExp)\n\n    let lastAlphabet: string[] = this.alphabet\n    const result: NumberLike[] = []\n\n    for (const subId of idArray) {\n      const buffer = [lotteryChar, ...this.salt, ...lastAlphabet]\n      const nextAlphabet = shuffle(\n        lastAlphabet,\n        buffer.slice(0, lastAlphabet.length),\n      )\n      result.push(fromAlphabet(Array.from(subId), nextAlphabet))\n      lastAlphabet = nextAlphabet\n    }\n\n    // if the result is different from what we'd expect, we return an empty result (malformed input):\n    if (this._encode(result).join('') !== id) return []\n    return result\n  }\n}\n\nconst minAlphabetLength = 16\nconst sepDiv = 3.5\nconst guardDiv = 12\n\nexport const keepUnique = <T>(content: Iterable<T>): T[] =>\n  Array.from(new Set(content))\n\nexport const withoutChars = (\n  chars: string[],\n  withoutChars: string[],\n): string[] => chars.filter((char) => !withoutChars.includes(char))\n\nexport const onlyChars = (chars: string[], keepChars: string[]): string[] =>\n  chars.filter((char) => keepChars.includes(char))\n\nconst isIntegerNumber = (n: NumberLike | string) =>\n  typeof n === 'bigint' ||\n  (!Number.isNaN(Number(n)) && Math.floor(Number(n)) === n)\n\nconst isPositiveAndFinite = (n: NumberLike) =>\n  typeof n === 'bigint' || (n >= 0 && Number.isSafeInteger(n))\n\nfunction shuffle(alphabetChars: string[], saltChars: string[]): string[] {\n  if (saltChars.length === 0) {\n    return alphabetChars\n  }\n\n  let integer: number\n  const transformed = alphabetChars.slice()\n\n  for (let i = transformed.length - 1, v = 0, p = 0; i > 0; i--, v++) {\n    v %= saltChars.length\n    p += integer = saltChars[v].codePointAt(0)!\n    const j = (integer + v + p) % i\n\n    // swap characters at positions i and j\n    const a = transformed[i]\n    const b = transformed[j]\n    transformed[j] = a\n    transformed[i] = b\n  }\n\n  return transformed\n}\n\nconst toAlphabet = (input: NumberLike, alphabetChars: string[]): string[] => {\n  const id: string[] = []\n\n  if (typeof input === 'bigint') {\n    const alphabetLength = BigInt(alphabetChars.length)\n    do {\n      id.unshift(alphabetChars[Number(input % alphabetLength)])\n      input = input / alphabetLength\n    } while (input > BigInt(0))\n  } else {\n    do {\n      id.unshift(alphabetChars[input % alphabetChars.length])\n      input = Math.floor(input / alphabetChars.length)\n    } while (input > 0)\n  }\n\n  return id\n}\n\nconst fromAlphabet = (\n  inputChars: string[],\n  alphabetChars: string[],\n): NumberLike =>\n  inputChars.reduce((carry, item) => {\n    const index = alphabetChars.indexOf(item)\n    if (index === -1) {\n      throw new Error(\n        `The provided ID (${inputChars.join(\n          '',\n        )}) is invalid, as it contains characters that do not exist in the alphabet (${alphabetChars.join(\n          '',\n        )})`,\n      )\n    }\n    if (typeof carry === 'bigint') {\n      return carry * BigInt(alphabetChars.length) + BigInt(index)\n    }\n    const value = carry * alphabetChars.length + index\n    const isSafeValue = Number.isSafeInteger(value)\n    if (isSafeValue) {\n      return value\n    } else {\n      if (typeof BigInt === 'function') {\n        return BigInt(carry) * BigInt(alphabetChars.length) + BigInt(index)\n      } else {\n        // we do not have support for BigInt:\n        throw new Error(\n          `Unable to decode the provided string, due to lack of support for BigInt numbers in the current environment`,\n        )\n      }\n    }\n  }, 0 as NumberLike)\n\nconst safeToParseNumberRegExp = /^\\+?[0-9]+$/\nconst safeParseInt10 = (str: string) =>\n  safeToParseNumberRegExp.test(str) ? parseInt(str, 10) : NaN\n\nconst splitAtIntervalAndMap = <T>(\n  str: string,\n  nth: number,\n  map: (n: string) => T,\n): T[] =>\n  Array.from<never, T>({length: Math.ceil(str.length / nth)}, (_, index) =>\n    map(str.slice(index * nth, (index + 1) * nth)),\n  )\n\nconst makeAnyOfCharsRegExp = (chars: string[]) =>\n  new RegExp(\n    chars\n      .map((char) => escapeRegExp(char))\n      // we need to sort these from longest to shortest,\n      // as they may contain multibyte unicode characters (these should come first)\n      .sort((a, b) => b.length - a.length)\n      .join('|'),\n  )\n\nconst makeAtLeastSomeCharRegExp = (chars: string[]) =>\n  new RegExp(\n    `^[${chars\n      .map((char) => escapeRegExp(char))\n      // we need to sort these from longest to shortest,\n      // as they may contain multibyte unicode characters (these should come first)\n      .sort((a, b) => b.length - a.length)\n      .join('')}]+$`,\n  )\n\nconst escapeRegExp = (text: string) =>\n  text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n"]}